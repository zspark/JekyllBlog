---
layout: post_with_wisdom
title: "程序性能优化" 
date:   2016-03-17
category: CS
published: false
excerpt: ""
wisdom: 就像望远镜之于天文学，计算机科学不仅仅是计算机。—— Edsger Dijkstra
meta: 
subImgPath: cg\image\
author: 
tags: [image,format,compression]
---


### 性能优化

1. 在追求性能的同时，建立扩展性强的软件结构；
3. 配置序列化，有助于快读解析；
4. 资源转码，至少有3个目的：1、适应具体硬件环境的架构；2、压缩；3、加密；
4. 采用流式资源打包方式，减少硬盘的寻址次数与时间；
5. 具体语言的特征，基于编译后汇编代码的的执行指令条数；
4. 子线程分担主线程压力，也可以使用分帧的方式降低单帧的集中处理压力；
4. 优化重要算法，采用必要数据结构加快针对性问题的处理速度；注意2、8原则；
6. 不要偏激于单一方面的性能；
6. 采用profiler；

1. AVL树的单旋转与双旋转
2. 伸展树（splay tree）
3. 二叉树

摊还时间。


## 哈希表

1. 分离链接法（separate chaining）
2. 探测散列表（probling hash tables）
	1. 线性散列；
	2. 平方散列；
3. 双散列；

## 二叉堆
1. 父节点的键值总是大于等于（或者小于等于）任何一个子节点的键值；
2. 每个子节点的左右子树也同样是一个二叉堆；

## 排序

|name|时间复杂度|说明|
|:---:|:---:|:---|
|插入排序（insertion sort）|O(N^2)||
|希尔排序（Shellsort）|O(N^2)|分割了几次的插入排序，难点在于分割值的选取| 
|归并排序（Mergesort）|O(NlogN)||
|快速排序（quick sort）|O(NlogN)||

## STL
STL三大件（容器、算法、迭代器）；
容器与容器之上执行的算法之间无需彼此了解。这种戏法是通过迭代器实现的。
迭代器提供了一种算法与容器相互协同工作的机制。一个容器可以生成一对迭代器来指定容器中的一个元素序列（可以是全部序列，也可是一个区间），而算法则对该序列进行操作。采用这种机制，使得容器与算法既可以紧密协作，又可以保持彼此“不知情”，这种“不知情”的好处，乃是C++高级编程领域反复强调的主题。

除了上面的内容以外，STL还定义了大量辅助性的功能。

STL的另一个优越性在于高度可配置性；

## 引用是别名而非指针
引用是一个现有对象的别名。用对象来初始化引用之后，那么对象的名字或引用的名字可以用于指向该对象。
指针与引用之间的区别：
1. 不存在空引用；
2. 所有引用都要初始化；
3. 一个引用永远指向用来对他初始化的那个对象；

## 数组形参
函数定义中，参数需要一个数组，但是实际传入中，只需要一个指向该数组的指针即可，这种从数组到指针的自动转换被赋予了一个迷人的技术术语：“退化”，即数组退化成一个指向其首元素的指针；(用函数名字做参数传递，也会退化成一个指针)


**指向类成员的指针并非指针，指向类成员函数的指针也不是指针**

## Factory Method
工厂方法的本质在于，基类提供一个虚函数“挂钩”，用于产生适当的“产品”。每一个派生类可以重写继承的虚函数，为自己产生适当的产品。

## 条款31 协变返回类型（covarient return type）
一般来说，一个重写的函数与被它重写的函数必须具有相同的返回类型；但是协变返回类型提供了一种在编译器进行检查的机制，尽可能减小运行时类型转化后可能出现的问题。


C++中子类不能继承父类的构造函数；父类的友元关系也不能被继承；


# Framework

1. 通信；（模块间通信、与网络的通信）；
2. 本地文件读取与保存；
3. 如何封装；
4. 底层库的决策（库更新，变动等）；
5. 设计先行、文档同步跟进；
6. 发布文件的格式定义，预留字段方便扩展；
7. 抽象

==EOF==

[google]:[http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&mid=402940847&idx=1&sn=4bb97ed9397a73fad7c24dac729d5728&scene=23&srcid=0317uVkHCC4U7Wz6LoJZFQce#rd]


酷爱Scala，喜欢造轮子，对函数式编程、并行程序开发、系统设计架构、代码之美等相关问题也有着浓厚的兴趣，同时非常希望能够靠写代码赚钱养老


