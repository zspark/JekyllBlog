---
layout: post_with_wisdom_mathjax
title:  "《交互式计算机图形学》复习笔记-图形系统和模型"
date:   2015-12-20
category: CG
published: true
excerpt: ""
wisdom: 如果你以为用户是白痴，那就只有白痴才用它。 —— 李纳斯·托沃兹（Linus Torvalds），LINUX之父
meta: 
author: 
tags: [计算机图形学 computer-graphics cg CG]
---

*{{site.blank}}这是我复习Edward Angal与Dave Shreiner的合著《交互式计算机图形学——基于OpenGl着色器的自顶向下方法（第六版）》的笔记，还是那句话，学而时习之，不亦乐乎*

{{site.blank}}计算机图形学（computer graphics）考虑的是用计算机生成图片或者图像的方方面面，包括但不限于图形图像的生成、处理、显示；
主要活跃的有至少两个分支：

* 图形人机接口；
* 可视化技术；

{{site.blank}}1995年第一款3dfx Voodoo图形加速度卡首次发布，GPU的绘制结构发生了明显变化，经历了从有限的固化算法（Fixed-Function GPU）到统一渲染架构下的完全可编程GPU（Programmable GPU），其后再经过OpenGL ES和WebGL扩展到移动互联网领域。

# 图形系统和模型

图形系统主要包括6个主要的物理部件：

* 输入设备；
* 输出设备；
* CPU；
* GPU；
* 存储器；
* 帧缓存；

> 所有现代图形系统都是基于光栅的。  ---《计算机图形学》第三版

## 呈像模型

* 虚拟照相机模型：从小孔成像说起；
* 笔试绘图仪模型：类似AS3中Graphic的成员方法，moveto，lineto

如果设计的图像系统是基于虚拟照相机模型的话，其在API的设计上需要有响应的函数来确定一下4中对象：

* 对象
* 观察者
* 光源
* 材质属性

## 图形绘制流水线

{{site.blank}}图元的类型与顶点集定义了场景的几何数据。一个普通场景可能需要几万甚至几十万个顶点，复杂场景就更多了。如此多的数据就需要流水线的方式去处理这些顶点，图形绘制流水线主要由两部分组成。

### 流水线前端处理

{{site.blank}}这个阶段的流水线主要针对顶点与图元在几何定义阶段的计算与处理，包括顶点处理与片元裁剪重组两个模块。

#### 顶点处理

{{site.blank}}顶点处理模块的功能是批量的对所有顶点进行矩阵变化与颜色计算，矩阵变换是指将模型在制作阶段的物体坐标系变换到3D场景的世界坐标系下，然后继续变换到观察者（照相机）坐标系下。这个过程至少需要2次矩阵乘法，我们可以先将模型变化矩阵与视角变化矩阵相乘，从而得到被称作`模视矩阵`的新矩阵，然后再与各个顶点相乘。
这个模块还捎带进行顶点颜色的计算，可以使用常见的光照模型，比如`Phong模型`；亦可使用立即数直接指定统一的顶点颜色。此前我有疑问为什么要这么早计算顶点的颜色或者计算的意义在哪里。首先顶点的关照计算肯定要放在绘制流水线的前端处理，因为无论什么场景在一帧中的显示画面是一定的，比如对象/光源位置、光源强度、观察角度等，而需要计算的是一大批符合物理光照规律的顶点，用流水线肯定没错。而计算的意义在于为后端光栅化处理向帧缓存写入片元颜色奠定的数据基础，不然一个线段只定义两个顶点，要绘制在显示器上，倘若没有顶点处理阶段时对颜色的指定（计算），线段中间的顶点选什么颜色？倘若端点颜色全部是黑色，中间顶点是黑色无可厚非；一个端点白色，一个黑色，中间顶点就需要插值计算，显示结果便是个渐变线段；指定固定颜色就更好说了，经常在Demo中看到的屏幕上一个红色三角面，那就是指定了三个顶点全是红色的绘制结果；

{{site.blank}}扩展一下说，目前GPU是完全可编程的，可编程体现在哪里？比如`Phong模型`中给顶点指定颜色，就是外部CPU参与计算（Phong光照计算就是一个公式，不外乎加减乘除，多一个幂函数计算），这个过程是编程人员高度可控可改的，最终结果返回给GPU的流水线即可（GPU的流水线就是个状态机，指点数据就不会变话，除非外部重新赋值），这就是高度可编程的直观体现；

#### 图元的裁剪与重组

{{site.blank}}注意这里词汇的变化，将`顶点`改成了`图元`。这就意味着这个模块处理的最小单元是由`顶点`构成的`图元`，所谓`图元`就是具体的`图形图像系统`指定的最基本的图形，比如三角形、线段、圆等。
{{site.blank}}从字面看“图元的裁剪与重组”这些字可以知道其要做的事情是将视角（摄像机、观察者的眼睛）确实不可见的图元彻底剔除，比如在人眼后边的，怎么着这个图元也不可能在这一帧中在显示器上成像。又将半遮半可见的按照一定的裁剪算法裁掉看不见的部分，然后将可见部分重组成一个或多个新的图元。其实该模块还包含其他过程。

{{site.blank}}裁剪掉的不作处理，处理了也没有意义。但能看见的图元尚需要进行投影变换（`透视投影`或者`正交投影`或者其他），其目的是将这些图元映射到`投影平面上`，从而防止光栅化后进行更多投影的矩阵计算。此期间会涉及到4纬矩阵，其中第四纬度一般会用来存储原始图元深度，从而在更后期的片元处理阶段比较大小决定谁应该压着谁。

### 流水线后端处理

{{site.blank}}这个阶段更多的操作是位级别的操作，比如光栅化阶段像素的填充，片元处理阶段片元颜色的混合；

#### 光栅化

{{site.blank}}光栅化就是将几何图元像素化。我们在给图元定义的时候，一个线段就是两个顶点，4个浮点数，一个三角形就是三个顶点。拿三个不共线的顶点来说吧，这么简单的数据想要在显示器上绘制出来一个完整的面，请问其他数据从何而来？比如三角形中间某一个像素颜色从何而来？位置从而而来？这就是光栅化模块要做的事情，它是利用高效的光栅化算法比如`Bresenham（布兰森汉姆）算法`、`DDA（数字微分分析器）算法`等，计算像素位置与差值计算颜色。每一个在视`锥体（frustum）`内的图元都要进行光栅化，其结果是将图元细分为`片元（fragment）`（片元可以认为是像素的一个超集，它所承载的数据不仅仅是像素的颜色，还有深度信息等等），输出会直接进入帧缓存中。在整个过程中，不可避免的会将在`视椎体`内但被更靠前的物体遮挡的图元也进行光栅化后将片元尝试载入帧缓存，此时会判断片元深度，从而丢掉被压着的片元。

#### 片元处理

{{site.blank}}片元处理是绘制流水线的最后一道工序，这个阶段才是我们经常说的`纹理映射`阶段。我们可以采用传统的纹理映射，也可以使用凹凸映射这种比较新的技术。映射结束后颜色缓存中的每个像素的颜色就是纹理必要位置的颜色，再与此前顶点处理阶段对顶点早期指定（或计算）的颜色进行某种混合，就成为最终屏幕像素的颜色了。此处‘某种混合’就OpenGL来说一共有16中，基本上概全了对颜色中任何一位的与或非异或等操作。

## 性能特征

《交互式计算机图形学》第一章还说到了性能特征，就是业界对于一款图像显示卡的判断，主要有两条：

* 能以多块的速度处理几何实体；
* 每秒能修改多少个帧缓存中像素的颜色；

## 总结

{{site.blank}}交计图中第一章重点我觉得就这些东西，它是一个总述的章节，希望能从全盘先给读者一个轮廓，然后带着问题、好奇与目前的初步理解从第二章开始按照上面的顺序往下走，这也是交计图这本书作者Edward Angel多年教学颇为成功的方式。博文有书中的语句也有自己的理解，犯错不要紧，及时改正就好。
 
==EOF==

[qicifangchen_baidu]:http://baike.baidu.com/link?url=XI8RIoMTxQa7NY8MYqHNJhLU7fpd8yDVvS1f8bGWQAQ2cZ1vOmDmq3HuvoxfbvBHfqxLRSTmuu0GbPMdmlz7na
