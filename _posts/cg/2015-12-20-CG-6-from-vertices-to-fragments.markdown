---
layout: post_with_wisdom_mathjax
title:  "《交互式计算机图形学》复习笔记六-从顶点到片元"
date:   2016-03-02
categories: jekyll CG
published: true
excerpt: "重点讨论裁剪、光栅化、隐藏面消除"
keywords: "cg,clippling,rasterization,hidden-surface removal,3d,计算机图形学,computer-graphics"
wisdom: 如果你以为用户是白痴，那就只有白痴才用它。 —— 李纳斯·托沃兹（Linus Torvalds），LINUX之父
meta: 
author: 
subImgPath: cg\vertices_to_fragments\
tags: [计算机图形学 computer-graphics cg CG]
---
##从顶点到片元

>“在计算机图形学中，图形的生成过程以应用程序为起点，而以图像的生成为终点。”	摘自《交互式计算机图形学》P.213

图形系统必须做的事情有两点：

* 每个几何对象必须通过图形绘制系统；
* 帧缓冲中要为显示的颜色赋值；

目前主流的绘制策略有两条：

* 面向对象的（object-oriented)： 面向对象的渲染策略需要大量的内存以及单独处理每个对象所需的大量时间开销，随着高密度存储技术的发展，这个已经不是主要问题，其局限性是：无法处理大部分的全局计算，比如光的反射计算；
* 面向图像的（image-oriented)：主要问题是需要事先使用优秀的数据结构为后期处理做数据基础，不然从像素出发的逆向绘制策略难以辨识哪些几何对象影响哪些像素。

###片元处理
{{site.blank}}片元处理需要至少从这两点去讨论，第一需要注意经过光栅化后的几何图元，它可能自带有一定的插值或者平面值颜色（来自顶点颜色属性），同时颜色又需要来自纹理，这两者之间需要一定的逻辑柔和起来，通常在片元着色器中使用分量积的逻辑计算方式；第二需要明白整个片元在计算颜色完毕后写入帧缓存的方式，我们可能需要用到glBlendFunc与glBlendEquation，一个用来调整等式的因子，一个用来调整等式的方程，比如用加法还是减法还是其他。

这里还说到隐藏面消除与背面剔除功能，这是两个概念，前者是说物体A被物体B全部遮挡，那么A就不要绘制；后者是说对于一个面是否要绘制正面与、或背面。

###裁剪
{{site.blank}}对裁剪的理解，不能局限与流水线中对图元的处理（在CVV中就保留，不在或者部分在的话就裁剪）。应用程序中采用一定的逻辑在流水线开始之前就屏蔽需要绘制的部分对象也是一种裁剪，比如采用八叉树等数据结构首先屏蔽在摄像头后面的物体，或者采用某种算法轻松计算出完全处于不透明实体后面的物体，然后排除此次渲染。这无疑是提高程序整体性能的关键步骤。

下面主要说下《交互式计算机图形学》中提到的两个2D（可扩展到3D）线段裁减算法：

1. Cohen-Sutherland算法
2. Liang-BarSky算法；（Liang是指梁友栋）

####Cohen-Sutherland Clipping
又叫“编码裁减算法”，是首个使用浮点减法和位操作相结合代替大量的高开销浮点乘法和除法的裁减算法。

优点：

1. 要处理的线段非常多，而实际显示在屏幕上的比较少时；
2. 可扩展到三维空间；

算法思路：

![img0][img0]图片来自交计图E文版

算法将四条屏幕的边无限延长，这样整个屏幕所在的平面被划分成了9个区域，并且进行编码，如上图所示。编码并非随意经行，假设四位编码为abcd，a位表征的是所有y值大于ymax的情况（大于的话就是1，小于为0），b位是所有y值小于ymin的情况（小于就是1，大于为0），c位表示所有x值大于xmax的情况，d位表示所有x值小于xmin的情况。屏幕所在区域（中间部分），全部为0。当给定一条线段后，首先对端点经行编码，端点在哪个区域就用哪个4位的编码表示即可。再次假设两个端点A、B的编码分别为：o1，o2.现在o1与o2之间就会存在下面四种情况：

1. o1=o2=0：两个端点都在中间区域，肯定不需要裁剪；
2. o1=0，o2!=0，或相反：说明有一个端点是在中间区域，另一个在外面，需要裁剪【注1】；
3. o1&o2!=0：说明两个端点在屏幕的同一外侧，这是可以完全丢弃的线段；
4. o1&o2=0：说明两个端点不在同一外侧，有可能横/斜穿中间区域，此时就需要经行裁剪【注2】；



【注1】：需要计算出线段与屏幕某条边缘的交点，之后使用在屏幕内的一部分；

【注2】：需要先计算出一个端点与屏幕某条边缘的交点，然后再利用新计算的交点与另一个端点计算出第二个交点，最后使用两个交点中间的部分（也就是留在屏幕中的线段）；

==EOF==

[img0]:{{site.basepath}}{{site.imgpath}}{{page.subImgPath}}image_Cohen-Sutherland-Clipping.jpg "img0"


