---
layout: post_with_wisdom
title:  "编程心得(二)"
date:   2015-06-23 11:40:33
category: thought
published: true
excerpt: "编程心得"
wisdom: 维护别人的代码就像是进入一栋设计得很漂亮的建筑，你一边逛一边景仰着，并盘算着加个侧厅或者重新装修一下什么的。不过这种情况太罕见了，更常见的是感觉是像被倒栽葱地一把扔进了又脏又臭的垃圾堆里。 —— 比尔·文纳斯（Bill Venners），《Programming in Scala》联合作者
meta: 
author: 
tags: [thoughts]
---

* 变动一个方法的时候，可以给新方法添加一个‘怪异’的行为，以便能在逻辑中很直观的被察觉到。这样你就可以第一时间察觉到哪些旧有的逻辑还在被使用；
* 内建类用来作为单例类创建时的唯一参数，这样就能客观保证不出第二个单例类实例；
* 销毁对象的时候记得只清除必要的连接，比如addEventListener或者dispose，不必要每个内部对象都执行销毁、断开引用，这样有助于提高性能；
* 记得固定字符串、数字等用常量表示，免得debug困难，因为编译器不会判断两个不同的字符串对于String类型有什么不同；
* 可以大胆的使用一个变量，但绝不可大胆的改变一个变量，除非你对其非常熟悉；
* 不要把逻辑写成一片，这样不方便阅读与重构，而且逻辑也势必很死板；
* 一次网络行为希望能有一条消息完事，不必有过多的消息；听同事说《xxx》项目的吃经验丹消息是一条对应吃一颗，这样的话如果玩家一次吃99颗经验丹，就意味着陆陆续续会收到至少99条消息，作死的姿态。
* 为什么不写成至返回一条信息呢？基于安全的考虑？我们这样分析下：如果说陆陆续续来99条消息比整体来1条安全，那么这99条的安全势必是基于“每一条都是安全的”为基础的，既然每一条都是安全的那么就一条好了。带宽、手机流量，前端流畅性都会有大幅度提升；
* 给变量起个优秀的名字；
* 什么叫逻辑与UI分离？就是如果你有哪怕一丝的逻辑未完成就千万不要参与UI的操作；
* 不要进行不必要的操作；如果一个变量经过之前的逻辑必定不会是空值，那么诸如先用if操作去判断其是否空值就起到了浪费一条或者几条指令的作用。
* 指定明确的变量类型；动态类对象成员在其寻址内容过程中势必没有静态类对象快，所以尽可能的去用静态类对象代替动态类对象；
* 集中同一种行为，有助于理解逻辑结构，使思路更加清晰；

{% highlight as3 linenos%}
clearItems();
var i:int=0;
Global.removeAll();
var item:MailItem;
for(i=0;i<mailList.length;i++){//TODO ...}
{% endhighlight %}

上面程序除了Global.removeAll()的话，其他的估计是一种行为，但在执行一种行为的程序中间插入一个看上去完全没有关系的Global逻辑，导致上下文逻辑各种穿插，没有章法。阅读起来感觉思路不清晰，想到什么写什么，绝非优秀的程序；
* 虽然强转或者用as关键字将数组中的对象指定为具体的对象会比直接读取慢一点（实测：1千万对象会慢200ms，视软硬件环境而定），但强转后大部分IDE会显示出其属性与方法，方便我们调用，不容易造成bug。坏处就是程序员过度依赖IDE，以至于使用Sublime、Vim等编写的时候各种忘记类名、函数名等等，不过这些编辑器有各种强大的插件，功能慢慢齐全倒也不是问题；
* 如果一个界面中两个UI控件（比如按钮）不可能同时被显示的话，为什么要创建2个然后再隐藏一个？完全可以视当时环境给唯一的控件指定不同的业务逻辑；
* 常犯的错误：判断布尔型变量，赋值布尔型变量；

{% highlight C++ linenos%}
bool a=true;
bool b;
if(a)b=true;
else b=false;
{% endhighlight %}

* 底层库接口的设计更加偏向于大众化，比如下面三个接口函数，对于库接口的设计而言，明显第三个好。但当接口的设计提高到应用层的时候，封装出来诸如第一、二个函数是没有问题的。这是编程哲学上的思考，没有对与错；

{% highlight as3 linenos%}
function changeColorToRed():void;
function changeColorToBlue():void;
function changeColorTo(color:uint):void;
{% endhighlight %}

* 不方便阅读或者需要用户使用前先计算参数值的接口不是个好接口；
* 不可否认，需要的时候再创建的好处是：
1. 节省不必要的资源开销；
2. 增强前端表现的流畅性；

* 有可能不会用到它为什么一定要创建它；
* 倘若子类没有用到直接父类的任何成员方法与成员变量，就不要继承它，除非有必要，比如统一处理；
* 换一个角度看待战斗系统的话，就是：一个活动的更频繁、更复杂、更有序的UI界面，所以完全可以用相同的一套底层逻辑；
* 对外接口最好不要让全部参数都附带缺省值，这样无助于开发者对接口参数的理解，也不方便其他开发者阅读；如果全部附带默认参数，直观的视觉反馈是一个不需要参数的函数调用，从而给大脑错误的信息；
* 不要把底层接口基本没做任何处理的封装一层丢给高层使用，那完全等于脱裤子放屁；
* 注释也是一门学问，比如进入场景地图可能有好几次调用不同的函数才能完成进入，此时就不要用类似“进入地图”，“进入地图前的逻辑”，“真正的进入场景”的语句去注释不同的函数，不但第三者迷惑，自己时间长了也会忘记；SP：Ruby语言哲学是“可视化”编程，就是用Ruby写的程序你甚至都不需要注释都能读得懂；
* 使用ADT编程，这也正是学习数据结构的目的。使用接口与组合编程，这正是OOP编程的本质； 

==EOF==
