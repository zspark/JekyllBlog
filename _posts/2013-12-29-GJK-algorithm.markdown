---
layout: post
title:  "GJK algorithm学习"
date:   2013-12-29 19:09:11
categories: jekyll cg
published: true
tags: [cg,graphic,gjk]
---

The Gilbert–Johnson–Keerthi Algorithm简称GJK算法`[Gilbert88]`，是由Gilbert、Johnson、Keerthi三人共同开发的一类迭代算法。GJK算法并不对参数本身做改变，而是利用参数计算明科夫斯基差，将两个点集的距离计算转化为一个点集与原点的计算问题，其迭代过程是不断判断逻辑上是否存在更有可能会包含原点的明科夫斯基子空间。

##算法的理论基础##
&#160; &#160; &#160; &#160;我们计算平面中两个点A，B距离的时候，最常见的方法就是用A向量减去B向量，然后再计算这个全新向量C的模，当我们进一步思考的时候就会发现新向量C的模其实又是向量C与原点O的距离。如此一来的话，我们可以简单的推导出这样一个事实：要计算平面中A、B两点的距离，可以尝试找到另一个点C，然后计算C与原点O的距离，也就是直接计算点C的模（三维空间亦是如此）；
这句话的重点并不是如何去计算点C，而是说两个变量之间的一些外部关系可以变换到一个变量的内部关系；
这是一个质的变化。
现在我们扩展到点集中，假设有两个点集SetA(n)与SetB(m)，由于其差集中的任何一个点必然是从SetA与SetB中计算而来，那么当差集中有一个点与原点重合的话，就意味着SetA与SetB中至少存在一对点Pa与Pb，它两的距离为0（重合在一起），不然的话差集中这个点从何而来？这就是GJK算法的理论基础，它的核心思想就是尝试计算差集中的点与原点的位置关系，从而确定点集A、B之间的位置关系；

计算几何中一个基本术语明科夫斯基差`Minkowsky minus`就与其相关；


##本文约定##
边缘点：明科夫斯基差空间下形成凸包的点；

差形：SetA中的点减去SetB中的点，所构成的明科夫斯基空间。

差集：构成差形的点集；


##明科夫斯基和`Minkowsky plus`##
&#160; &#160; &#160; &#160;先说说明科夫斯基和，其本质就是两个变量的加法运算，变量可以是但不限于一维、二维、三维向量，其和就是向量的对应分量和，结果自然也是个同纬度的向量；明科夫斯基和在几何上的直观表现就是SetA的凸包以SetB的凸包形状移动之后的扫略图形。当然会有一些修正，但这不是重点，也易于理解，
明科夫斯基差可以看作是SetA与SetB关于原点对称点集SetB’的和，深层含义可以参考平面中两点距离的思考。

##支持函数`support function`##
&#160; &#160; &#160; &#160;我们现在知道两个点集SetA(n)，与SetB(m)，SetA中有n个空间点，SetB中有m个空间点；倘若SetA中的任何一个点去与SetB中的任何一个点尝试计算`Minkowsky Minus`，会是一种什么情况：就会产生n*m个空间点，而这些点中必然有许多不是在SetC(n*m)的凸包点集中（而在差形中间），这就意味着去计算这些点的Minkowsky Minus是一种既无助于我们最后的判断，又浪费大量的计算时间的操作，我们肯定要尝试去减少这样的计算，最好没有一个多余的计算，于是支持函数就这样出现了。
我们使用支持函数去试图找到理论上一定在差形边缘上的点，最好是其顶点。怎么做到呢？我们知道，凡是差集中的点都是一个点集中的点去减去另一个点集中的点，倘若SetA在右边，SetB在左边，那么我用SetA中最右边（x值最大）的点减去SetB中最左边（x值最小）的点，其形成的点的x坐标肯定是最大（没有比它更大的），那么这个点p肯定就在差形边缘上或者就是个顶点，这样我们就找到了一个有价值的点。同理，当我们用SetA中最右边的点减去SetB中最右边的点，形成的新的顶点肯定也在差形边缘，因为再没有其他点的x值会比这个点的小。上下方向也是一样，我们甚至也可以用倾斜的方向。尝试提出他们的共性：都是给一个具体的方向，得出这个方向下SetA中的最远的点（或者最近的点），然后得到这个方向下SetB中最近的点（或者最远的点），他们做Minkowsky Minus计算后，结果点肯定在差形的边缘。

####支持函数的具体逻辑：####
{% highlight as3%}
 private function supportFn(SetA:Array,SetB:Array,dir:Vector2D):Vector2D{
        var mostFarInSetA:Vector2D=getFarthestPoint(SetA,dir);
        var mostNearInSetB:Vector2D=getFarthestPoint(SetB,-dir);

        var mkwPoint:Vector2D=mostFarInSetA-mostNearInSetB;
        return mkwPoint;
}
{% endhighlight %}

##单纯形##
&#160; &#160; &#160; &#160;有了支持函数后，我们便更近了一步，因为从此之后我们得到的任何一个点都会是在差形的边缘（或者是其顶点），接下来就是判断差形与原点的位置关系了。
如下图，我们计算出了差形中的一个点M，但我们难以仅以M与原点O有位置关系判断出整个差形与原点的位置关系，所以需要我们再得到更多的边缘点。一般的做法就是简单的反转得到点M的方向，然后计算另一个点，这样做是有一定原因的，其一：反转一个向量的方向要比全新创建一个向量速度快；其二：从目前仅有的点M我们无法知道整个差形的形状（甚至是大概形状），如下图，差形可能与原点有好多关系。所以在这样信息不全的情况下，我们没有必要大费周折去计算一个自认为更优秀的点。那就仅仅反转下方向，计算第二个边缘点吧。
有了点N
要想形成一个平面形状，至少要有三个点，组成一个单纯形，然后判断原点是否在其中，在的话表明SetA与SetB相交。





##向量三重积##
&#160; &#160; &#160; &#160;一般学习线性代数都会遇到三重积，但那个是标量三重积，意思就是先计算两个向量的叉积，其结果再与最后一个向量做点积，最后的结果是个标量，可理解为空间菱状体的体积；
而向量三重积意思是三个向量全部使用叉积计算，其最终结果依然是个向量，就我所知的计算机领域（计算机图形学，碰撞检测）里面其用途主要用来计算方向；
当我们找到2个差形边缘点后，第三个点的查找便有了一定的依据，因为我们的目的就是判断原点是否在差形里面，所以第三个点的查找肯定是向着原点的方向，否则便是徒劳。
如图下图所示，红色箭头就是希望寻找的方向，它与A，B两点垂直，要计算该方向需要用到向量三重积，新的方向下会计算出来一个新边缘点，这样就形成了一个三角形，现在问题是如何判断这个单纯形（三角形）包含原点呢？


##Voronoi域##
&#160; &#160; &#160; &#160;Voronoi域是计算几何分支的一个重要概念，这里仅说二位空间下的Voronoi域。当我们将一个平面凸图形的每条边延长后会发现整个二维空间被分割成几个区域如图所示，这些区域中有的占有原来图形的一条边，有的仅占有一个点，有的却占有整个面，除此之外别无其他，这三种不同的区域就是三种Voronoi特征域，依次被称作边域、点域、面域。
当我们计算出单纯形中的三个点后，能肯定的是其他边缘点肯定不会在点域，因为如果存在的话，该点域所在的唯一点便是单纯形中的一个内部点，这根使用支持函数计算边缘点相矛盾，故此倘若再有其他边缘点肯定不会落于当前单纯形的顶点域中，这样一来我们的判断就可以分割成判断原点是否落于面域之内。
判断点落于那个Voronoi域最简单的做法就是判断点与组成图形边的位置关系，问题便简化为点与线段的计算，更进一步便是点积的正负问题。


##迭代计算##
&#160; &#160; &#160; &#160;当我们判断出原点位于某个点域内，便能一口得出SetA与SetB不相交；而位于面域内便是一定相交。边域的话就需要进一步计算，此时就要判断应该丢掉第一个得出的边缘点还是第二个（第三个是在第一、二个边缘点的存在下得出的，故此它比前两个更具有有效性，试想如果丢掉第三个点，再次计算不还是得到第三个点嘛）。判断的依据依然是原点落在了哪个Voronoi边域内，如图，落在A域的话，自然丢掉A点；
丢掉后便是第一次递归计算了，与之前一样找出点三个点，然后全新的判断一次Voronoi域域原点的位置关系，直到肯定的退出或者逻辑有个迭代上限而退出。


##参考资料##

[dyn4j][url_a]

[physics2d][url_b]



[url_a]:http://www.codezealot.org/archives/153#gjk-convexhull
[url_b]:http://physics2d.com/content/gjk-algorithm
