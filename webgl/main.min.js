const STAGE_COLOR={r:.5,g:.5,b:.5,a:1.0};
var g_ctx;
var CASE={};
CASE.currentCase=null;
function init() {

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Creatation of main GUI .
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	var mainMenu=new function (){
		this.frame=function(){openCase(CASE.Case1); };
		this.triangle=function(){openCase(CASE.Case2); };
		this.rotation=function(){openCase(CASE.Case3); };
	};

	var mainGUI=new dat.GUI({autoPlace:false});
	// mainGUI.add(mainMenu,"frame");
	mainGUI.add(mainMenu,"triangle");
	mainGUI.add(mainMenu,"rotation");

	document.getElementById('mainMenuDiv').appendChild(mainGUI.domElement);

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Get WebGL context;
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	var cvs=document.getElementById("cvs");
	cvs.width=window.innerWidth;
	cvs.height=window.innerHeight;
	g_ctx=create3DContext(cvs);
	setDefaultGLContext();
	//
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//resize;
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	window.onresize=function (evt){
		var cvs=document.getElementById("cvs");
		cvs.width=window.innerWidth;
		cvs.height=window.innerHeight;
		// log:console.log("(w:h)"+window.innerWidth+','+window.innerHeight);
	}
	//
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// Provides requestAnimationFrame in a cross browser
	/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec. 
	 * 
	 * Cancels an animation frame request. 
	 * Checks for cross-browser support, falls back to clearTimeout. 
	 * @param {number}  Animation frame request. */
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = (function() {
			return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
				window.setTimeout(callback, 1000/60);
			};
		})();
	}
	if (!window.cancelAnimationFrame) {
		window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||
				window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||
				window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||
				window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||
				window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||
				window.clearTimeout);
	}
}//end of init

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Global fns;
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
function create3DContext (canvas, opt_attribs) {
	var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var context = null;
	for (var ii = 0; ii < names.length; ++ii) {
		try {
			context = canvas.getContext(names[ii], opt_attribs);
		} catch(e) {}
		if (context) {
			break;
		}
	}
	return context;
}

function setDefaultGLContext(){
	if(g_ctx!=null){
		g_ctx.clearColor(STAGE_COLOR.r,STAGE_COLOR.g,STAGE_COLOR.b,STAGE_COLOR.a);
		g_ctx.clear(g_ctx.COLOR_BUFFER_BIT);
	}else
		throw "WebGL context was not created yet!";
}


function openCase(fn){
	if(fn==null){
		alert("No such case exist, Case open failure! index="+index);
		return ;
	}
	if(CASE.currentCase!=null){
		document.getElementById("caseMenuDiv").removeChild(CASE.currentCase.gui.domElement);
		window.cancelAnimationFrame(CASE.currentCase.update);
		CASE.currentCase.destroy();
	}
	CASE.currentCase=new fn();
	document.getElementById("caseMenuDiv").appendChild(CASE.currentCase.gui.domElement);
	caseUpdate();
};

function caseUpdate(){
	window.requestAnimationFrame(caseUpdate);
	CASE.currentCase.update_internal();
};





CASE.CaseBase=function (){
	this.ctx=g_ctx;
	this._started_=false;
	this.gui=new dat.GUI({autoPlace:false});
	this.gui.case=this;
	//this.gui=new dat.GUI();
}

CASE.CaseBase.prototype={

	destroy:function(){
		this.ctx.clear(0x000000);
		this.ctx=null; 
	},

	update_internal:function(){},
	update:function (){},

	start:function (){
		if(!this._started_){
			this.update_internal=this.update;
			this._started_=true;
		}
	},

	stop:function (){
		if(this._started_){
			this.update_internal=function(){};
			this._started_=false;
		}
	},

	createGUI:function(){},

	initWebGLStatus:function(){},

	initShaders:(function(){

		function createProgram( vshader, fshader) {
			// Create shader object
			var gl=g_ctx;
			var vertexShader = loadShader( gl.VERTEX_SHADER, vshader);
			var fragmentShader = loadShader( gl.FRAGMENT_SHADER, fshader);
			if (!vertexShader || !fragmentShader) {
				return null;
			}

			// Create a program object
			var program = gl.createProgram();
			if (!program) {
				return null;
			}

			// Attach the shader objects
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);

			// Link the program object
			gl.linkProgram(program);

			// Check the result of linking
			var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (!linked) {
				var error = gl.getProgramInfoLog(program);
				console.log('Failed to link program: ' + error);
				gl.deleteProgram(program);
				gl.deleteShader(fragmentShader);
				gl.deleteShader(vertexShader);
				return null;
			}
			return program;
		};

		function loadShader(type, source) {
			// Create shader object
			var gl=g_ctx;
			var shader = gl.createShader(type);
			if (shader == null) {
				console.log('unable to create shader');
				return null;
			}

			// Set the shader program
			gl.shaderSource(shader, source);

			// Compile the shader
			gl.compileShader(shader);

			// Check the result of compilation
			var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if (!compiled) {
				var error = gl.getShaderInfoLog(shader);
				console.log('Failed to compile shader: ' + error);
				gl.deleteShader(shader);
				return null;
			}

			return shader;
		};
		var fn=function (vshader,fshader){
			var gl=g_ctx;
			var program = createProgram( vshader, fshader);
			if (!program) {
				console.log('Failed to create program');
				return false;
			}

			gl.useProgram(program);
			gl.program = program;

			return true;

		};
		return fn;
	}()),

//	return {
//		constructor:CASE.CaseBase,
//		destroy:destroy,initShaders:initShaders,start:start,stop:stop,update:update
//	};
};

CASE.Case1=function (){
	CASE.CaseBase.call(this);

	//this.initShaders( VSHADER_SOURCE, FSHADER_SOURCE);   // Initialize shaders
}

CASE.Case1.prototype=Object.create(CASE.CaseBase.prototype);
CASE.Case1.prototype.constructor=CASE.Case1;
CASE.Case1.prototype.destroy=function(){
	CASE.CaseBase.prototype.destroy.call(this);
	//TODO:other destroy logic;
};

CASE.Case2=function (){
	CASE.CaseBase.call(this);

	var gl=this.ctx;

	this.createGUI();
	this.initWebGLStatus();
	this.initShaders( VSHADER_SOURCE, FSHADER_SOURCE);   // Initialize shaders

	this.pc = new Float32Array([ 
			// Vertex coordinates and color
			0.0,  0.5,  -0.1,  0.0,  0.0,  1.0,  
			-0.5, -0.5,  -0.1,  0.0,  1.0,  0.0,
			0.5, -0.5,  -0.1,  0.0,  0.0,  1.0, 
			]);

	this.pcbuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, this.pcbuffer);

	var numVertex = 3; var numColor = 3; 
	var FSIZE = this.pc.BYTES_PER_ELEMENT;   // The number of byte
	var STRIDE = numVertex + numColor;// Stride
	this.a_Position = gl.getAttribLocation(gl.program, 'a_Position');
	gl.vertexAttribPointer(this.a_Position, numVertex, gl.FLOAT, false, FSIZE * STRIDE, 0);
	gl.enableVertexAttribArray(this.a_Position);

	// Assign the vertex colors to attribute variable and enable the assignment
	this.a_Color = gl.getAttribLocation(gl.program, 'a_Color');
	gl.vertexAttribPointer(this.a_Color, numColor, gl.FLOAT, false, FSIZE * STRIDE, FSIZE * numVertex);
	gl.enableVertexAttribArray(this.a_Color);


	this.start();
}

CASE.Case2.prototype=Object.create(CASE.CaseBase.prototype);
CASE.Case2.prototype.constructor=CASE.Case2;
CASE.Case2.prototype.destroy=function(){
	setDefaultGLContext();
	CASE.CaseBase.prototype.destroy.call(this);
}

CASE.Case2.prototype.update=function(){
	this.ctx.clear(this.ctx.COLOR_BUFFER_BIT);      // Clear <canvas>
	this.pc[3]=this.ctrlData.topColor[0]/255;
	this.pc[4]=this.ctrlData.topColor[1]/255;
	this.pc[5]=this.ctrlData.topColor[2]/255;
	this.pc[9]=this.ctrlData.leftColor[0]/255;
	this.pc[10]=this.ctrlData.leftColor[1]/255;
	this.pc[11]=this.ctrlData.leftColor[2]/255;
	this.pc[15]=this.ctrlData.rightColor[0]/255;
	this.pc[16]=this.ctrlData.rightColor[1]/255;
	this.pc[17]=this.ctrlData.rightColor[2]/255;
	this.ctx.bufferData(this.ctx.ARRAY_BUFFER, this.pc, this.ctx.STATIC_DRAW);
	this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 3);  // Draw the triangles	
}

CASE.Case2.prototype.createGUI=function(){
	this.ctrlData=new function(){
		this.topColor=[255,0,0];
		this.leftColor=[0,255,0];
		this.rightColor=[0,0,255];
	};

	var gui=this.gui;
	gui.addColor(this.ctrlData,"topColor");
	gui.addColor(this.ctrlData,"leftColor");
	gui.addColor(this.ctrlData,"rightColor");

}



CASE.Case2.prototype.initWebGLStatus=function(){
	var gl=this.ctx;
	// gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Specify the color for clearing <canvas>
	gl.clear(gl.COLOR_BUFFER_BIT);      // Clear <canvas>
	console.log("color setted");
}


var VSHADER_SOURCE =
'attribute vec4 a_Position;\n' +
' attribute vec4 a_Color;\n' +
'varying vec4 v_Color;\n' +
'void main() {\n' +
	'  gl_Position = a_Position;\n' +
		'  v_Color = a_Color;\n' +
		'}\n';

		// Fragment shader program
		var FSHADER_SOURCE =
		'#ifdef GL_ES\n' +
		'precision mediump float;\n' +
		'#endif\n' +
		'varying vec4 v_Color;\n' +
		'void main() {\n' +
			'  gl_FragColor = v_Color;\n' +
				'}\n';

CASE.Case3=function (){
	CASE.CaseBase.call(this);

	var gl=this.ctx;

	this.createGUI();
	this.initWebGLStatus();
	this.initShaders( VSHADER_SOURCE, FSHADER_SOURCE);   // Initialize shaders

	this.pc = new Float32Array([ 
			// Vertex coordinates and color
			0.0,  0.5,  -0.1,  1.0,  0.0,  0.0,  
			-0.5, -0.5,  -0.1,  0.0,  1.0,  0.0,
			0.5, -0.5,  -0.1,  0.0,  0.0,  1.0, 
			]);

	this.pcbuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, this.pcbuffer);

	var numVertex = 3; var numColor = 3; 
	var FSIZE = this.pc.BYTES_PER_ELEMENT;   // The number of byte
	var STRIDE = numVertex + numColor;// Stride
	this.a_Position = gl.getAttribLocation(gl.program, 'a_Position');
	gl.vertexAttribPointer(this.a_Position, numVertex, gl.FLOAT, false, FSIZE * STRIDE, 0);
	gl.enableVertexAttribArray(this.a_Position);

	// Assign the vertex colors to attribute variable and enable the assignment
	this.a_Color = gl.getAttribLocation(gl.program, 'a_Color');
	gl.vertexAttribPointer(this.a_Color, numColor, gl.FLOAT, false, FSIZE * STRIDE, FSIZE * numVertex);
	gl.enableVertexAttribArray(this.a_Color);


	this.start();
}

CASE.Case3.prototype=Object.create(CASE.CaseBase.prototype);
CASE.Case3.prototype.constructor=CASE.Case3;
CASE.Case3.prototype.destroy=function(){
	setDefaultGLContext();

	CASE.CaseBase.prototype.destroy.call(this);
}

CASE.Case3.prototype.update=function(){
	//计算新的坐标点；
	var angularVelocity=this.ctrlData.angularVelocity;
	var cos=Math.cos(angularVelocity);
	var sin=Math.sin(angularVelocity);
	var tmp=this.pc[0];
	var tmp2=this.pc[1];
	this.pc[0]=tmp*cos+tmp2*sin;
	this.pc[1]=-sin*tmp+tmp2*cos;
	tmp=this.pc[6];
	tmp2=this.pc[7];
	this.pc[6]=tmp*cos+tmp2*sin;
	this.pc[7]=-sin*tmp+tmp2*cos;
	tmp=this.pc[12];
	tmp2=this.pc[13];
	this.pc[12]=tmp*cos+tmp2*sin;
	this.pc[13]=-sin*tmp+tmp2*cos;

	//render
	this.ctx.clear(this.ctx.COLOR_BUFFER_BIT);      // Clear <canvas>
	this.ctx.bufferData(this.ctx.ARRAY_BUFFER,this.pc, this.ctx.STATIC_DRAW);
	this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 3);  // Draw the triangles	

}

CASE.Case3.prototype.createGUI=function(){
	this.ctrlData=new function(){
		this.angularVelocity=.003;
		this.play=true;
	};

	var gui=this.gui;
	gui.add(this.ctrlData,"angularVelocity",0,.01);
	gui.add(this.ctrlData,"play").onChange(
		function(value){
			var self=this.__gui.case;
			if(value)self.start();	
			else self.stop();
		}
	);
}

CASE.Case3.prototype.initWebGLStatus=function(){
	var gl=this.ctx;
	gl.clear(gl.COLOR_BUFFER_BIT);      // Clear <canvas>
}


var VSHADER_SOURCE =
'attribute vec4 a_Position;\n' +
'attribute vec4 a_Color;\n' +
'varying vec4 v_Color;\n' +
'void main() {\n' +
	'  gl_Position = a_Position;\n' +
		'  v_Color = a_Color;\n' +
		'}\n';

		// Fragment shader program
		var FSHADER_SOURCE =
		'#ifdef GL_ES\n' +
		'precision mediump float;\n' +
		'#endif\n' +
		'varying vec4 v_Color;\n' +
		'void main() {\n' +
			'  gl_FragColor = v_Color;\n' +
				'}\n';

